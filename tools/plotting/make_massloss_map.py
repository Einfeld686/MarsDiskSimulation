"""Render the one-orbit mass-loss fraction map produced by sweep_massloss_map."""
from __future__ import annotations

import argparse
from pathlib import Path

import matplotlib

matplotlib.use("Agg")
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd


def _resolve_table_path(path: Path) -> Path:
    suffix = path.suffix.lower()
    if suffix == ".csv":
        parquet_path = path.with_suffix(".parquet")
        if parquet_path.exists():
            if not path.exists() or parquet_path.stat().st_mtime >= path.stat().st_mtime:
                return parquet_path
    elif suffix in {".parquet", ".pq"} and not path.exists():
        csv_path = path.with_suffix(".csv")
        if csv_path.exists():
            return csv_path
    return path


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Visualise loss_frac = (M_out_cum + M_sink_cum) / M_init over (r/R_M, T_M)."
    )
    parser.add_argument("--map", type=Path, required=True, help="Input CSV generated by sweep_massloss_map.")
    parser.add_argument(
        "--out",
        type=Path,
        default=None,
        help="Output PNG path (defaults to fig_massloss_map.png adjacent to the map directory).",
    )
    parser.add_argument("--cmap", type=str, default="magma", help="Matplotlib colormap (default: magma).")
    parser.add_argument("--vmax", type=float, default=None, help="Optional upper bound for the colour scale.")
    parser.add_argument(
        "--no-contour",
        action="store_true",
        help="Disable the sink_frac contour overlay.",
    )
    parser.add_argument(
        "--contour-levels",
        nargs="*",
        type=float,
        default=(0.25, 0.5),
        help="Contour levels for sink_frac (default: 0.25 0.5).",
    )
    parser.add_argument(
        "--steps-per-orbit",
        type=int,
        default=100,
        help="Nominal integration steps per orbit for the annotation (default: 100).",
    )
    return parser.parse_args()


def _build_grid(df: pd.DataFrame, column: str, r_vals: np.ndarray, T_vals: np.ndarray) -> np.ndarray:
    grid = np.full((T_vals.size, r_vals.size), np.nan, dtype=float)
    index_r = {float(value): idx for idx, value in enumerate(r_vals)}
    index_T = {float(value): idx for idx, value in enumerate(T_vals)}
    for row in df.itertuples():
        r_idx = index_r.get(float(row.r_RM))
        T_idx = index_T.get(float(row.T_M))
        if r_idx is None or T_idx is None:
            continue
        value = getattr(row, column, np.nan)
        grid[T_idx, r_idx] = float(value)
    return grid


def main() -> None:
    args = parse_args()
    map_path = _resolve_table_path(args.map)
    if not map_path.exists():
        raise FileNotFoundError(f"CSV file not found: {map_path}")
    if map_path.suffix.lower() in {".parquet", ".pq"}:
        df = pd.read_parquet(map_path)
    else:
        df = pd.read_csv(map_path)
    required_cols = {"r_RM", "T_M", "loss_frac", "sink_frac", "qpr_table_path", "dt_over_t_blow_median"}
    missing = sorted(required_cols - set(df.columns))
    if missing:
        raise KeyError(f"Input CSV missing required columns: {', '.join(missing)}")

    r_vals = np.sort(df["r_RM"].unique())
    T_vals = np.sort(df["T_M"].unique())
    if r_vals.size == 0 or T_vals.size == 0:
        raise ValueError("CSV must contain at least one row with r_RM and T_M values.")

    grid_loss = _build_grid(df, "loss_frac", r_vals, T_vals)
    grid_sink = _build_grid(df, "sink_frac", r_vals, T_vals)

    vmin = 0.0
    vmax_data = float(np.nanmax(grid_loss)) if np.isfinite(grid_loss).any() else 1.0
    vmax = args.vmax if args.vmax is not None else vmax_data
    extent = (
        float(r_vals.min()),
        float(r_vals.max()),
        float(T_vals.min()),
        float(T_vals.max()),
    )

    fig, ax = plt.subplots(figsize=(6, 4))
    im = ax.imshow(
        grid_loss,
        origin="lower",
        extent=extent,
        aspect="auto",
        cmap=args.cmap,
        vmin=vmin,
        vmax=vmax,
    )
    ax.set_xlabel("r / R_M")
    ax.set_ylabel("T_M [K]")
    ax.set_title("loss_frac = (M_out_cum + M_sink_cum)/M_init (one orbit)")

    cbar = fig.colorbar(im, ax=ax)
    cbar.set_label("loss_frac")

    if not args.no_contour and np.isfinite(grid_sink).any():
        masked = np.ma.masked_invalid(grid_sink)
        levels = list(args.contour_levels)
        if levels:
            try:
                cs = ax.contour(
                    r_vals,
                    T_vals,
                    masked,
                    levels=levels,
                    colors="white",
                    linewidths=1.0,
                    linestyles="dashed",
                )
                ax.clabel(cs, inline=True, fmt="sink_frac=%.2f", fontsize=7, colors="white")
            except ValueError:
                pass  # contour requires at least a 2x2 grid of finite values; ignore when absent

    dt_ratio_global = float(np.nanmedian(df["dt_over_t_blow_median"]))
    qpr_paths = sorted({Path(value).name for value in df["qpr_table_path"].dropna().unique()})
    legend_lines = [
        "loss_frac = (M_out_cum + M_sink_cum)/M_init",
        f"steps/orbit ≈ {args.steps_per_orbit}",
        f"median Δt / t_blow = {dt_ratio_global:.3f}",
        f"Q_pr table(s): {', '.join(qpr_paths)}",
        f"cells: {df.shape[0]}",
    ]
    ax.text(
        0.02,
        0.98,
        "\n".join(legend_lines),
        transform=ax.transAxes,
        ha="left",
        va="top",
        fontsize=8,
        bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.85),
    )

    out_path = args.out
    if out_path is None:
        out_path = args.map.parent.parent / "fig_massloss_map.png"
    out_path.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(out_path, dpi=220)
    plt.close(fig)


if __name__ == "__main__":
    main()
