タスクDを実行しました。どのVersionが最も適切か理由とともに判断してください。どのVersionも適切でない場合は、理由とともに適切なVersionが存在しないと出力してください。また、微修正するべき点がある場合はファイル名と共に具体的に何を修正するべきか明記してください。pandasが環境に存在しないことによるエラーは評価対象から除外してください。
 「入力プロンプト」
Codex実行の前提・ルール・計算仕様

	•	前提と出力先
	•	0次元・半径固定の表面薄層モデル。火星半径 R_{\rm Mars}=3{,}389{,}500\ \mathrm{m}。
	•	積分既定：t_{\rm end}=0.01\ \mathrm{yr}、初期刻み \Delta t=10^4\ \mathrm{s}。
	•	主要出力：summary.json（総逸失量ほか集計）、series/run.parquet（時系列）、results/map{ID}.csv、図は figures/ 配下。
	•	RNGは固定seedで決定的に（再現性）。
	•	物理の骨子（先に平易→用語提示→以後は平易語）
	1.	考え方：表面にある小粒子は、火星からの光で外向きに押される。押す力が重力の半分を超えると、粒子は縛られず逃げる。
	2.	用語：この比を**β（放射圧/重力の比）**と呼ぶ。**吹き飛ばし（blow‑out）**の判定は β≳0.5。
	3.	以後：βと、そこから導く**「吹き飛ばし最小径」 s_{\rm blow}** を使って逃避/不逃避を判定する。
	•	βと s_{\rm blow} の計算（火星の熱放射から決める）
	•	想定：粒子は灰色体、吸収効率 Q_{\rm pr}\approx1（無ければ1.0、範囲チェック時は0.5–1.5で感度）。粒子密度 \rho は設定から取得（なければ 3{,}000\ \mathrm{kg\,m^{-3}}）。
	•	β は半径に依らず一定（放射圧・重力とも \propto r^{-2} のため）。
	•	式：
\beta \;=\;\frac{F_{\rm rad}}{F_{\rm grav}}\;=\;\frac{3\,\sigma_{\rm SB}\,T_M^4\,R_M^2\,Q_{\rm pr}}{4\,G\,M_M\,c\,\rho\,s}
s_{\rm blow}\;(\beta{=}0.5)\;=\;\frac{3\,\sigma_{\rm SB}\,T_M^4\,R_M^2\,Q_{\rm pr}}{2\,G\,M_M\,c\,\rho}
ここで T_M は火星表面の黒体温度、R_M,M_M は火星の半径と質量、s は粒子半径、\sigma_{\rm SB} はステファン=ボルツマン定数。
	•	運用：
	•	入力に T_M, Q_{\rm pr}, \rho があれば上式でβと s_{\rm blow} を毎ケースで計算。なければ既定 Q_{\rm pr}{=}1,\ \rho{=}3{,}000\ \mathrm{kg\,m^{-3}}。
	•	判定：設定した最小粒径 s_{\min} に対し、\beta(s_{\min})\ge 0.5 なら「吹き飛ばし成立」。成立しない場合は温度・粒径・密度に応じて case_status='failed'。
	•	ログ：各ケースに beta_at_smin, s_blow_m, Q_pr_used, rho_used を出力。s_min_effective は昇華・衝突クリップ後の有効最小径。\,s_{\min,\mathrm{eff}}>s_{\min} を明示。
	•	温度と半径のレンジ（固定の想定）
	•	温度 T_M：1000–6000 K（既定50 K刻み）。
	•	半径 r_{\rm RM}：既定 1.0–3.0（0.1刻み）。任意拡張として 5.0–7.0 も後述の Map‑1b で検証可（出力分離）。
	•	可視化の規約
	•	ヒートマップは total_mass_lost_Mmars の対数。欠損や不成立は灰色＋ハッチ。
	•	カラーバー範囲はCSVの min/max（有限値）と一致させ、図内テキストに log10(M/M_Mars) を明記。
	•	追加図（必要時）：s_min_effective の等高線や有効域マスク。
	•	実務ルール
	•	Map‑3（21,000件）は分割実行（例：s_{\min}の対数領域をN分割し results/parts/ へ保存→最後に結合）。
	•	途中中断に備え、case単位の完了フラグと再開を実装。
	•	テーブル（Q_{\rm pr}, 自己遮蔽 \Phi(\tau) など）が未指定なら近似に自動フォールバックしつつ、メタ情報を警告ログに残す（実行は継続）。

タスクD｜可視化の更新
	•	results/map{ID}.csv → figures/map{ID}_total_mass_lost_Mmars.png を再生成（\log_{10}、灰色＋ハッチ、凡例一貫）。
	•	カラーバー整合テスト：CSVの有限値 min/max と画像の範囲が一致。case_status="failed" が帯として連続表示。

Codexが満たすべき条件（品質・再現・安全）
	1.	再現性：全実行でseed固定、環境依存の乱れを排除。
	2.	決定的I/O：各ケースにユニークID、case_status、beta_at_smin、s_blow_m、s_min_effective を必ず記録。
	3.	堅牢化：テーブル欠如時は警告して近似にフォールバック、存在時はエラーで停止（パス不整合の早期発見）。
	4.	分割耐性：Map‑3は部分CSVの結合手順をコード化。中断→再開で重複出力無し。
	5.	検証：
	•	Map‑1の成立域で M/r^2 の分布が一定±許容（例±10%）であることを自動確認。
	•	図のカラーバー範囲とCSVの整合を自動Assert。
	6.	記録：run_config.json に使用式（βと s_{\rm blow} の式）、定数、既定値、gitのcommit等を保存。

根拠と参照（リサーチに基づく補足）
	•	事後衝突の火星温度：T_M \sim 1000–6000\ \mathrm{K} の加熱領域が出る。泠却は力学時系列より遅い（最外縁は放射に晒される）。本指示の温度レンジ設定の根拠。 
	•	吹き飛ばし基準と s_{\rm blow}：β は放射圧/重力の比、β≳0.5 で重力束縛を失う。s_{\rm blow} の扱いと「最小径の引上げ」挙動の参照。 
	•	外縁半径の動機付け：同期軌道は \sim 6 R_M。フォボス/ダイモス起源域は 5–7 R_M の示唆（拡張Map‑1bの背景）。 
	•	表層流出と代表粒径：光学的厚い円盤でも表面層では放射圧で外向き流出が起こり、主搬送粒径は~0.1 μm。本モデルの「表面薄層」近似の注意に対応。 
	•	火星起源系での放射圧・脱揮発の可能性：事後衝突の高温火星からの放射圧でミクロン級凝縮物が除去され得ること（本モデルのβ駆動に整合）。

「Version 1」
Summary
デフォルトの質量損失メトリクスを描く際、カラーバーのラベルを log10(M/M_Mars) として図中に明示しました。
case_status が failed のセルを連続した灰色ハッチ帯として描画し、凡例にも failed 帯を追加して視認性を高めました。
Testing
⚠️ pytest tests/test_map1_validations.py （pandas が未インストールのため ModuleNotFoundError）
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..a6d6a0cb1015c4b427e02a5474ea526efcaf81cb 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -165,65 +165,105 @@ def plot_heatmap(
     im = ax.imshow(
         masked_log,
         origin="lower",
         cmap=cmap,
         aspect="auto",
         vmin=log_min,
         vmax=log_max,
     )
 
     x_ticks = np.arange(len(x_values))
     y_ticks = np.arange(len(y_values))
     ax.set_xticks(x_ticks)
     ax.set_xticklabels([format_tick_label(v) for v in x_values], rotation=45, ha="right")
     ax.set_yticks(y_ticks)
     ax.set_yticklabels([format_tick_label(v) for v in y_values])
     ax.set_xlabel(x_label)
     ax.set_ylabel(y_label)
     ax.set_title(f"{map_label}: {metric}")
 
     ax.set_xticks(np.arange(-0.5, len(x_values), 1), minor=True)
     ax.set_yticks(np.arange(-0.5, len(y_values), 1), minor=True)
     ax.grid(which="minor", color="white", linewidth=0.5)
     ax.tick_params(which="minor", bottom=False, left=False)
 
     cbar = fig.colorbar(im, ax=ax)
-    cbar.set_label(f"log10({metric})")
+    if metric == DEFAULT_METRIC:
+        cbar.set_label("log10(M/M_Mars)")
+    else:
+        cbar.set_label(f"log10({metric})")
 
     invalid_mask = ~np.isfinite(original_values) | (original_values <= 0.0)
     if np.any(invalid_mask):
-        for (y_idx, x_idx) in zip(*np.where(invalid_mask)):
+        legend_patch_added = False
+        for y_idx, row in enumerate(invalid_mask):
+            x_indices = np.where(row)[0]
+            if x_indices.size == 0:
+                continue
+            start = x_indices[0]
+            prev = x_indices[0]
+            for x_idx in x_indices[1:]:
+                if x_idx == prev + 1:
+                    prev = x_idx
+                    continue
+                rect = patches.Rectangle(
+                    (start - 0.5, y_idx - 0.5),
+                    prev - start + 1.0,
+                    1.0,
+                    facecolor="lightgray",
+                    hatch="///",
+                    edgecolor="gray",
+                    linewidth=0.8,
+                    zorder=5,
+                )
+                ax.add_patch(rect)
+                start = x_idx
+                prev = x_idx
             rect = patches.Rectangle(
-                (x_idx - 0.5, y_idx - 0.5),
+                (start - 0.5, y_idx - 0.5),
+                prev - start + 1.0,
                 1.0,
-                1.0,
-                facecolor="none",
+                facecolor="lightgray",
                 hatch="///",
                 edgecolor="gray",
                 linewidth=0.8,
+                zorder=5,
             )
             ax.add_patch(rect)
+            legend_patch_added = True
+        if legend_patch_added:
+            legend_handles, legend_labels = ax.get_legend_handles_labels()
+            legend_handles.append(
+                patches.Patch(
+                    facecolor="lightgray",
+                    edgecolor="gray",
+                    hatch="///",
+                    label="case_status = failed",
+                )
+            )
+            legend_labels.append("case_status = failed")
+            ax.legend(legend_handles, legend_labels, loc="upper right")
 
     clim = im.get_clim()
     if not np.allclose(clim, (log_min, log_max), rtol=1e-6, atol=1e-8):
         raise RuntimeError("カラーバー範囲がCSVの最小値/最大値と一致しません。")
 
     fig.tight_layout()
     ensure_directory(output_path.parent)
     fig.savefig(output_path, dpi=300)
     plt.close(fig)
 
     return log_min, log_max
 
 
 def sanitize_metric_name(metric: str) -> str:
     """ファイル名に使いやすいメトリクス名へ変換する。"""
 
     return re.sub(r"[^A-Za-z0-9_.-]", "_", metric)
 
 
 def maybe_plot_mass_per_r2_scatter(df: pd.DataFrame, map_stub: str, map_label: str) -> None:
     """Map-1 系列向けの M/r^2 散布図を保存する。"""
 
     if "mass_per_r2" not in df.columns:
         return
     working = df.copy()
 
EOF
)

「Version 2」
バージョン1

バージョン2

バージョン3

バージョン4
Summary
plot_heatmaps.py にカラーバー専用ラベル関数と失敗セルをまとめて塗りつぶす add_failed_case_hatching を追加し、case_status="failed" 領域を灰色ハッチの連続した帯として描画できるようにしました。
ヒートマップ描画仕様を検証するための単体テストを marsdisk/tests/test_plot_heatmaps.py に追加し、pandas が無い環境では自動的にスキップするようにしました。
Testing
⚠️ pytest（環境に pandas が無いため収集時に ModuleNotFoundError）
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a//dev/null b/marsdisk/tests/test_plot_heatmaps.py
index 0000000000000000000000000000000000000000..b2440418e9c2d99d2beae16de7f63c9c0dee00aa 100644
--- a//dev/null
+++ b/marsdisk/tests/test_plot_heatmaps.py
@@ -0,0 +1,42 @@
+import matplotlib
+
+matplotlib.use("Agg")
+
+import numpy as np
+import pytest
+from matplotlib import colors as mcolors
+from matplotlib import pyplot as plt
+
+pytest.importorskip("pandas")
+
+from scripts import plot_heatmaps as ph
+
+
+def test_colorbar_label_default_metric():
+    assert ph.colorbar_label(ph.DEFAULT_METRIC) == "log10(M/M_Mars)"
+
+
+def test_colorbar_label_custom_metric():
+    assert ph.colorbar_label("custom_metric") == "log10(custom_metric)"
+
+
+def test_add_failed_case_hatching_creates_horizontal_band():
+    fig, ax = plt.subplots()
+    mask = np.array([[True, True, False]])
+    patches = ph.add_failed_case_hatching(ax, mask)
+    assert len(patches) == 1
+    patch = patches[0]
+    assert np.isclose(patch.get_width(), 2.0)
+    assert np.isclose(patch.get_height(), 1.0)
+    assert patch.get_zorder() > 2.5
+    expected_face = mcolors.to_rgba("lightgray")
+    actual_face = patch.get_facecolor()
+    assert np.allclose(actual_face, expected_face)
+    plt.close(fig)
+
+
+def test_add_failed_case_hatching_rejects_invalid_dimension():
+    fig, ax = plt.subplots()
+    with np.testing.assert_raises(ValueError):
+        ph.add_failed_case_hatching(ax, np.array([True, False, True]))
+    plt.close(fig)
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..4af6050847564d594fa1e0a3479728bb417f39c3 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -1,40 +1,43 @@
 """Plot heatmaps and diagnostics from parameter sweep results."""
 from __future__ import annotations
 
 import argparse
 import math
 import re
 import sys
 from pathlib import Path
 from typing import Iterable, List, Sequence, Tuple
 
 import matplotlib.pyplot as plt
 import numpy as np
 import pandas as pd
 from matplotlib import patches
 
+# figures の凡例要件: total_mass_lost_Mmars の場合は log10(M/M_Mars) を明記
+LOG_LABEL_DEFAULT_METRIC = "log10(M/M_Mars)"
+
 BLOWOUT_STATUS = "blowout"
 DEFAULT_METRIC = "total_mass_lost_Mmars"
 
 
 def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
     """コマンドライン引数を解釈する。"""
 
     parser = argparse.ArgumentParser(
         description="results/map*.csv からヒートマップを生成して figures/ に保存します。"
     )
     parser.add_argument(
         "--map",
         type=str,
         required=True,
         help="読み込むマップ番号 (1, 1b, 2, 3)",
     )
     parser.add_argument(
         "--metric",
         type=str,
         default=DEFAULT_METRIC,
         help=f"ヒートマップに用いる列名 (デフォルト: {DEFAULT_METRIC})",
     )
     return parser.parse_args(list(argv) if argv is not None else None)
 
 
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..4af6050847564d594fa1e0a3479728bb417f39c3 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -122,108 +125,156 @@ def prepare_pivot(
     pivot = working.pivot(index="param_y_value", columns="param_x_value", values=metric)
     pivot = pivot.reindex(
         index=pd.Index(y_order, name=pivot.index.name),
         columns=pd.Index(x_order, name=pivot.columns.name),
     )
 
     return pivot, x_order, y_order, str(x_label), str(y_label)
 
 
 def compute_log_values(pivot: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray, float, float]:
     """元の値と log10 値 (マスク付き) を計算する。"""
 
     values = pivot.to_numpy(dtype=float)
     finite = np.isfinite(values) & (values > 0.0)
     if not np.any(finite):
         raise ValueError("指定されたメトリクスに有効な値がありません。")
 
     log_values = np.full_like(values, np.nan, dtype=float)
     log_values[finite] = np.log10(values[finite])
     masked_log = np.ma.masked_invalid(log_values)
     log_min = float(np.min(log_values[finite]))
     log_max = float(np.max(log_values[finite]))
     return values, masked_log, log_min, log_max
 
 
+def colorbar_label(metric: str) -> str:
+    """カラーバーに表示するラベルを返す。"""
+
+    return LOG_LABEL_DEFAULT_METRIC if metric == DEFAULT_METRIC else f"log10({metric})"
+
+
+def add_failed_case_hatching(
+    ax: plt.Axes, invalid_mask: np.ndarray
+) -> List[patches.Patch]:
+    """case_status="failed" など無効セルの灰色ハッチを帯状に描画する。"""
+
+    if invalid_mask.ndim != 2:
+        raise ValueError("invalid_mask は 2 次元配列である必要があります。")
+
+    patches_added: List[patches.Patch] = []
+    rows, cols = invalid_mask.shape
+    if rows == 0 or cols == 0:
+        return patches_added
+
+    face_rgba = "lightgray"
+    edge_rgba = "dimgray"
+    for y_idx in range(rows):
+        run_start = None
+        for x_idx in range(cols):
+            if invalid_mask[y_idx, x_idx]:
+                if run_start is None:
+                    run_start = x_idx
+            elif run_start is not None:
+                patch = patches.Rectangle(
+                    (run_start - 0.5, y_idx - 0.5),
+                    (x_idx - run_start),
+                    1.0,
+                    facecolor=face_rgba,
+                    hatch="///",
+                    edgecolor=edge_rgba,
+                    linewidth=0.0,
+                    zorder=3.0,
+                )
+                ax.add_patch(patch)
+                patches_added.append(patch)
+                run_start = None
+        if run_start is not None:
+            patch = patches.Rectangle(
+                (run_start - 0.5, y_idx - 0.5),
+                (cols - run_start),
+                1.0,
+                facecolor=face_rgba,
+                hatch="///",
+                edgecolor=edge_rgba,
+                linewidth=0.0,
+                zorder=3.0,
+            )
+            ax.add_patch(patch)
+            patches_added.append(patch)
+
+    return patches_added
+
+
 def plot_heatmap(
     map_label: str,
     metric: str,
     pivot: pd.DataFrame,
     x_values: List[object],
     y_values: List[object],
     x_label: str,
     y_label: str,
     output_path: Path,
 ) -> Tuple[float, float]:
     """ヒートマップを描画して保存する。"""
 
     original_values, masked_log, log_min, log_max = compute_log_values(pivot)
 
     cmap = plt.get_cmap("viridis").copy()
     cmap.set_bad(color="lightgray")
 
     fig, ax = plt.subplots(figsize=(7.0, 6.0))
     im = ax.imshow(
         masked_log,
         origin="lower",
         cmap=cmap,
         aspect="auto",
         vmin=log_min,
         vmax=log_max,
     )
 
     x_ticks = np.arange(len(x_values))
     y_ticks = np.arange(len(y_values))
     ax.set_xticks(x_ticks)
     ax.set_xticklabels([format_tick_label(v) for v in x_values], rotation=45, ha="right")
     ax.set_yticks(y_ticks)
     ax.set_yticklabels([format_tick_label(v) for v in y_values])
     ax.set_xlabel(x_label)
     ax.set_ylabel(y_label)
     ax.set_title(f"{map_label}: {metric}")
 
     ax.set_xticks(np.arange(-0.5, len(x_values), 1), minor=True)
     ax.set_yticks(np.arange(-0.5, len(y_values), 1), minor=True)
     ax.grid(which="minor", color="white", linewidth=0.5)
     ax.tick_params(which="minor", bottom=False, left=False)
 
     cbar = fig.colorbar(im, ax=ax)
-    cbar.set_label(f"log10({metric})")
+    cbar.set_label(colorbar_label(metric))
 
     invalid_mask = ~np.isfinite(original_values) | (original_values <= 0.0)
     if np.any(invalid_mask):
-        for (y_idx, x_idx) in zip(*np.where(invalid_mask)):
-            rect = patches.Rectangle(
-                (x_idx - 0.5, y_idx - 0.5),
-                1.0,
-                1.0,
-                facecolor="none",
-                hatch="///",
-                edgecolor="gray",
-                linewidth=0.8,
-            )
-            ax.add_patch(rect)
+        add_failed_case_hatching(ax, invalid_mask)
 
     clim = im.get_clim()
     if not np.allclose(clim, (log_min, log_max), rtol=1e-6, atol=1e-8):
         raise RuntimeError("カラーバー範囲がCSVの最小値/最大値と一致しません。")
 
     fig.tight_layout()
     ensure_directory(output_path.parent)
     fig.savefig(output_path, dpi=300)
     plt.close(fig)
 
     return log_min, log_max
 
 
 def sanitize_metric_name(metric: str) -> str:
     """ファイル名に使いやすいメトリクス名へ変換する。"""
 
     return re.sub(r"[^A-Za-z0-9_.-]", "_", metric)
 
 
 def maybe_plot_mass_per_r2_scatter(df: pd.DataFrame, map_stub: str, map_label: str) -> None:
     """Map-1 系列向けの M/r^2 散布図を保存する。"""
 
     if "mass_per_r2" not in df.columns:
         return
     working = df.copy()
 
EOF
)

「Version 3」
Codex実行の前提・ルール・計算仕様

	•	前提と出力先
	•	0次元・半径固定の表面薄層モデル。火星半径 R_{\rm Mars}=3{,}389{,}500\ \mathrm{m}。
	•	積分既定：t_{\rm end}=0.01\ \mathrm{yr}、初期刻み \Delta t=10^4\ \mathrm{s}。
	•	主要出力：summary.json（総逸失量ほか集計）、series/run.parquet（時系列）、results/map{ID}.csv、図は figures/ 配下。
	•	RNGは固定seedで決定的に（再現性）。
	•	物理の骨子（先に平易→用語提示→以後は平易語）
	1.	考え方：表面にある小粒子は、火星からの光で外向きに押される。押す力が重力の半分を超えると、粒子は縛られず逃げる。
	2.	用語：この比を**β（放射圧/重力の比）**と呼ぶ。**吹き飛ばし（blow‑out）**の判定は β≳0.5。
	3.	以後：βと、そこから導く**「吹き飛ばし最小径」 s_{\rm blow}** を使って逃避/不逃避を判定する。
	•	βと s_{\rm blow} の計算（火星の熱放射から決める）
	•	想定：粒子は灰色体、吸収効率 Q_{\rm pr}\approx1（無ければ1.0、範囲チェック時は0.5–1.5で感度）。粒子密度 \rho は設定から取得（なければ 3{,}000\ \mathrm{kg\,m^{-3}}）。
	•	β は半径に依らず一定（放射圧・重力とも \propto r^{-2} のため）。
	•	式：
\beta \;=\;\frac{F_{\rm rad}}{F_{\rm grav}}\;=\;\frac{3\,\sigma_{\rm SB}\,T_M^4\,R_M^2\,Q_{\rm pr}}{4\,G\,M_M\,c\,\rho\,s}
s_{\rm blow}\;(\beta{=}0.5)\;=\;\frac{3\,\sigma_{\rm SB}\,T_M^4\,R_M^2\,Q_{\rm pr}}{2\,G\,M_M\,c\,\rho}
ここで T_M は火星表面の黒体温度、R_M,M_M は火星の半径と質量、s は粒子半径、\sigma_{\rm SB} はステファン=ボルツマン定数。
	•	運用：
	•	入力に T_M, Q_{\rm pr}, \rho があれば上式でβと s_{\rm blow} を毎ケースで計算。なければ既定 Q_{\rm pr}{=}1,\ \rho{=}3{,}000\ \mathrm{kg\,m^{-3}}。
	•	判定：設定した最小粒径 s_{\min} に対し、\beta(s_{\min})\ge 0.5 なら「吹き飛ばし成立」。成立しない場合は温度・粒径・密度に応じて case_status='failed'。
	•	ログ：各ケースに beta_at_smin, s_blow_m, Q_pr_used, rho_used を出力。s_min_effective は昇華・衝突クリップ後の有効最小径。\,s_{\min,\mathrm{eff}}>s_{\min} を明示。
	•	温度と半径のレンジ（固定の想定）
	•	温度 T_M：1000–6000 K（既定50 K刻み）。
	•	半径 r_{\rm RM}：既定 1.0–3.0（0.1刻み）。任意拡張として 5.0–7.0 も後述の Map‑1b で検証可（出力分離）。
	•	可視化の規約
	•	ヒートマップは total_mass_lost_Mmars の対数。欠損や不成立は灰色＋ハッチ。
	•	カラーバー範囲はCSVの min/max（有限値）と一致させ、図内テキストに log10(M/M_Mars) を明記。
	•	追加図（必要時）：s_min_effective の等高線や有効域マスク。
	•	実務ルール
	•	Map‑3（21,000件）は分割実行（例：s_{\min}の対数領域をN分割し results/parts/ へ保存→最後に結合）。
	•	途中中断に備え、case単位の完了フラグと再開を実装。
	•	テーブル（Q_{\rm pr}, 自己遮蔽 \Phi(\tau) など）が未指定なら近似に自動フォールバックしつつ、メタ情報を警告ログに残す（実行は継続）。

タスクD｜可視化の更新
	•	results/map{ID}.csv → figures/map{ID}_total_mass_lost_Mmars.png を再生成（\log_{10}、灰色＋ハッチ、凡例一貫）。
	•	カラーバー整合テスト：CSVの有限値 min/max と画像の範囲が一致。case_status="failed" が帯として連続表示。

Codexが満たすべき条件（品質・再現・安全）
	1.	再現性：全実行でseed固定、環境依存の乱れを排除。
	2.	決定的I/O：各ケースにユニークID、case_status、beta_at_smin、s_blow_m、s_min_effective を必ず記録。
	3.	堅牢化：テーブル欠如時は警告して近似にフォールバック、存在時はエラーで停止（パス不整合の早期発見）。
	4.	分割耐性：Map‑3は部分CSVの結合手順をコード化。中断→再開で重複出力無し。
	5.	検証：
	•	Map‑1の成立域で M/r^2 の分布が一定±許容（例±10%）であることを自動確認。
	•	図のカラーバー範囲とCSVの整合を自動Assert。
	6.	記録：run_config.json に使用式（βと s_{\rm blow} の式）、定数、既定値、gitのcommit等を保存。

根拠と参照（リサーチに基づく補足）
	•	事後衝突の火星温度：T_M \sim 1000–6000\ \mathrm{K} の加熱領域が出る。泠却は力学時系列より遅い（最外縁は放射に晒される）。本指示の温度レンジ設定の根拠。 
	•	吹き飛ばし基準と s_{\rm blow}：β は放射圧/重力の比、β≳0.5 で重力束縛を失う。s_{\rm blow} の扱いと「最小径の引上げ」挙動の参照。 
	•	外縁半径の動機付け：同期軌道は \sim 6 R_M。フォボス/ダイモス起源域は 5–7 R_M の示唆（拡張Map‑1bの背景）。 
	•	表層流出と代表粒径：光学的厚い円盤でも表面層では放射圧で外向き流出が起こり、主搬送粒径は~0.1 μm。本モデルの「表面薄層」近似の注意に対応。 
	•	火星起源系での放射圧・脱揮発の可能性：事後衝突の高温火星からの放射圧でミクロン級凝縮物が除去され得ること（本モデルのβ駆動に整合）。
コピーする

バージョン1

バージョン2

バージョン3

バージョン4
Summary
scripts/plot_heatmaps.py を更新し、ヒートマップへ log10(M/M_Mars) 注記と非 blowout 領域の連続ハッチ帯・凡例を追加しつつ、CSV 由来のカラーバー範囲整合チェックを保持しました。 
同スクリプトに s_min_effective 等高線図と有効域ハイライト生成を追加して、必要時に追加図を figures/ へ保存できるよう拡張しました。 
Testing
✅ python -m compileall scripts/plot_heatmaps.py 
⚠️ pytest（依存ライブラリ pandas 不足により収集中に失敗）
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..11006dc1b59b30232298dc8aada24a1bd0e813d8 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -1,39 +1,40 @@
 """Plot heatmaps and diagnostics from parameter sweep results."""
 from __future__ import annotations
 
 import argparse
 import math
 import re
 import sys
 from pathlib import Path
 from typing import Iterable, List, Sequence, Tuple
 
 import matplotlib.pyplot as plt
 import numpy as np
 import pandas as pd
 from matplotlib import patches
+from matplotlib.colors import ListedColormap
 
 BLOWOUT_STATUS = "blowout"
 DEFAULT_METRIC = "total_mass_lost_Mmars"
 
 
 def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
     """コマンドライン引数を解釈する。"""
 
     parser = argparse.ArgumentParser(
         description="results/map*.csv からヒートマップを生成して figures/ に保存します。"
     )
     parser.add_argument(
         "--map",
         type=str,
         required=True,
         help="読み込むマップ番号 (1, 1b, 2, 3)",
     )
     parser.add_argument(
         "--metric",
         type=str,
         default=DEFAULT_METRIC,
         help=f"ヒートマップに用いる列名 (デフォルト: {DEFAULT_METRIC})",
     )
     return parser.parse_args(list(argv) if argv is not None else None)
 
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..11006dc1b59b30232298dc8aada24a1bd0e813d8 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -122,119 +123,357 @@ def prepare_pivot(
     pivot = working.pivot(index="param_y_value", columns="param_x_value", values=metric)
     pivot = pivot.reindex(
         index=pd.Index(y_order, name=pivot.index.name),
         columns=pd.Index(x_order, name=pivot.columns.name),
     )
 
     return pivot, x_order, y_order, str(x_label), str(y_label)
 
 
 def compute_log_values(pivot: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray, float, float]:
     """元の値と log10 値 (マスク付き) を計算する。"""
 
     values = pivot.to_numpy(dtype=float)
     finite = np.isfinite(values) & (values > 0.0)
     if not np.any(finite):
         raise ValueError("指定されたメトリクスに有効な値がありません。")
 
     log_values = np.full_like(values, np.nan, dtype=float)
     log_values[finite] = np.log10(values[finite])
     masked_log = np.ma.masked_invalid(log_values)
     log_min = float(np.min(log_values[finite]))
     log_max = float(np.max(log_values[finite]))
     return values, masked_log, log_min, log_max
 
 
+def _group_invalid_runs(invalid_mask: np.ndarray) -> List[Tuple[int, int, int]]:
+    """Return contiguous :math:`x`-ranges of invalid cells for each :math:`y` index."""
+
+    runs: List[Tuple[int, int, int]] = []
+    for y_idx, row in enumerate(invalid_mask):
+        start = None
+        for x_idx, is_invalid in enumerate(row):
+            if is_invalid:
+                if start is None:
+                    start = x_idx
+            elif start is not None:
+                runs.append((y_idx, start, x_idx - 1))
+                start = None
+        if start is not None:
+            runs.append((y_idx, start, len(row) - 1))
+    return runs
+
+
 def plot_heatmap(
     map_label: str,
     metric: str,
     pivot: pd.DataFrame,
     x_values: List[object],
     y_values: List[object],
     x_label: str,
     y_label: str,
     output_path: Path,
-) -> Tuple[float, float]:
+) -> Tuple[float, float, np.ndarray]:
     """ヒートマップを描画して保存する。"""
 
     original_values, masked_log, log_min, log_max = compute_log_values(pivot)
 
     cmap = plt.get_cmap("viridis").copy()
     cmap.set_bad(color="lightgray")
 
     fig, ax = plt.subplots(figsize=(7.0, 6.0))
     im = ax.imshow(
         masked_log,
         origin="lower",
         cmap=cmap,
         aspect="auto",
         vmin=log_min,
         vmax=log_max,
     )
 
     x_ticks = np.arange(len(x_values))
     y_ticks = np.arange(len(y_values))
     ax.set_xticks(x_ticks)
     ax.set_xticklabels([format_tick_label(v) for v in x_values], rotation=45, ha="right")
     ax.set_yticks(y_ticks)
     ax.set_yticklabels([format_tick_label(v) for v in y_values])
     ax.set_xlabel(x_label)
     ax.set_ylabel(y_label)
     ax.set_title(f"{map_label}: {metric}")
 
     ax.set_xticks(np.arange(-0.5, len(x_values), 1), minor=True)
     ax.set_yticks(np.arange(-0.5, len(y_values), 1), minor=True)
     ax.grid(which="minor", color="white", linewidth=0.5)
     ax.tick_params(which="minor", bottom=False, left=False)
 
+    legend_handles: List[patches.Patch] = []
+
     cbar = fig.colorbar(im, ax=ax)
-    cbar.set_label(f"log10({metric})")
+    colorbar_label = f"log10({metric})"
+    if metric == DEFAULT_METRIC:
+        colorbar_label = "log10(M/M_Mars)"
+    cbar.set_label(colorbar_label)
+
+    annotation_text = colorbar_label
+    ax.text(
+        0.02,
+        0.98,
+        annotation_text,
+        transform=ax.transAxes,
+        ha="left",
+        va="top",
+        fontsize=10,
+        bbox={
+            "boxstyle": "round,pad=0.3",
+            "facecolor": "white",
+            "edgecolor": "none",
+            "alpha": 0.75,
+        },
+    )
 
     invalid_mask = ~np.isfinite(original_values) | (original_values <= 0.0)
     if np.any(invalid_mask):
-        for (y_idx, x_idx) in zip(*np.where(invalid_mask)):
+        for y_idx, x_start, x_end in _group_invalid_runs(invalid_mask):
+            width = (x_end - x_start) + 1
             rect = patches.Rectangle(
-                (x_idx - 0.5, y_idx - 0.5),
-                1.0,
+                (x_start - 0.5, y_idx - 0.5),
+                width,
                 1.0,
                 facecolor="none",
                 hatch="///",
                 edgecolor="gray",
                 linewidth=0.8,
             )
             ax.add_patch(rect)
+        legend_handles.append(
+            patches.Patch(
+                facecolor="lightgray",
+                edgecolor="gray",
+                hatch="///",
+                label="case_status ≠ blowout",
+            )
+        )
+
+    if legend_handles:
+        ax.legend(handles=legend_handles, loc="upper right", frameon=True)
 
     clim = im.get_clim()
     if not np.allclose(clim, (log_min, log_max), rtol=1e-6, atol=1e-8):
         raise RuntimeError("カラーバー範囲がCSVの最小値/最大値と一致しません。")
 
     fig.tight_layout()
     ensure_directory(output_path.parent)
     fig.savefig(output_path, dpi=300)
     plt.close(fig)
 
-    return log_min, log_max
+    return log_min, log_max, invalid_mask
+
+
+def _prepare_boolean_indicator(
+    df: pd.DataFrame, column: str, true_values: Iterable[str] | None = None
+) -> pd.DataFrame:
+    """Return a dataframe with numeric indicator column for boolean-style flags."""
+
+    if true_values is None:
+        true_values = {"true", "1", "yes", "y", "on"}
+    true_values_set = {str(v).lower() for v in true_values}
+    working = df.copy()
+    working[column] = (
+        working[column]
+        .astype(str)
+        .str.lower()
+        .map(lambda val: 1.0 if val in true_values_set else 0.0)
+    )
+    return working
+
+
+def maybe_plot_smin_effective_contours(
+    df: pd.DataFrame,
+    map_stub: str,
+    map_label: str,
+    x_values: List[object],
+    y_values: List[object],
+    x_label: str,
+    y_label: str,
+) -> None:
+    """出力CSVに s_min_effective があれば等高線図を追加生成する。"""
+
+    metric = "s_min_effective"
+    if metric not in df.columns:
+        return
+
+    try:
+        pivot, _, _, _, _ = prepare_pivot(df, metric)
+    except ValueError:
+        return
+
+    pivot = pivot.reindex(
+        index=pd.Index(y_values, name=pivot.index.name),
+        columns=pd.Index(x_values, name=pivot.columns.name),
+    )
+    values = pivot.to_numpy(dtype=float)
+    finite = np.isfinite(values) & (values > 0.0)
+    if not np.any(finite):
+        return
+
+    log_values = np.full_like(values, np.nan, dtype=float)
+    log_values[finite] = np.log10(values[finite])
+    masked_log = np.ma.masked_invalid(log_values)
+    log_min = float(np.min(log_values[finite]))
+    log_max = float(np.max(log_values[finite]))
+
+    cmap = plt.get_cmap("cividis").copy()
+    cmap.set_bad(color="lightgray")
+
+    fig, ax = plt.subplots(figsize=(7.0, 6.0))
+    im = ax.imshow(
+        masked_log,
+        origin="lower",
+        cmap=cmap,
+        aspect="auto",
+    )
+
+    x_ticks = np.arange(len(x_values))
+    y_ticks = np.arange(len(y_values))
+    ax.set_xticks(x_ticks)
+    ax.set_xticklabels([format_tick_label(v) for v in x_values], rotation=45, ha="right")
+    ax.set_yticks(y_ticks)
+    ax.set_yticklabels([format_tick_label(v) for v in y_values])
+    ax.set_xlabel(x_label)
+    ax.set_ylabel(y_label)
+    ax.set_title(f"{map_label}: s_min_effective")
+
+    cbar = fig.colorbar(im, ax=ax)
+    cbar_label = "log10(s_min_effective [m])"
+    cbar.set_label(cbar_label)
+    ax.text(
+        0.02,
+        0.98,
+        cbar_label,
+        transform=ax.transAxes,
+        ha="left",
+        va="top",
+        fontsize=10,
+        bbox={
+            "boxstyle": "round,pad=0.3",
+            "facecolor": "white",
+            "edgecolor": "none",
+            "alpha": 0.75,
+        },
+    )
+
+    legend_handles: List[patches.Patch] = []
+
+    if log_max > log_min:
+        xi = np.arange(len(x_values))
+        yi = np.arange(len(y_values))
+        X, Y = np.meshgrid(xi, yi)
+        num_levels = max(4, min(10, int(round(log_max - log_min) * 5) + 1))
+        levels = np.linspace(log_min, log_max, num_levels)
+        contour = ax.contour(
+            X,
+            Y,
+            masked_log,
+            levels=levels,
+            colors="black",
+            linewidths=0.8,
+        )
+        ax.clabel(contour, fmt=lambda val: f"10^{val:.2f}", fontsize=9)
+
+    invalid_mask = ~finite
+    if np.any(invalid_mask):
+        for y_idx, x_start, x_end in _group_invalid_runs(invalid_mask):
+            width = (x_end - x_start) + 1
+            rect = patches.Rectangle(
+                (x_start - 0.5, y_idx - 0.5),
+                width,
+                1.0,
+                facecolor="none",
+                hatch="///",
+                edgecolor="gray",
+                linewidth=0.8,
+            )
+            ax.add_patch(rect)
+        legend_handles.append(
+            patches.Patch(
+                facecolor="lightgray",
+                edgecolor="gray",
+                hatch="///",
+                label="case_status ≠ blowout",
+            )
+        )
+
+    flag_column = "s_min_effective_gt_config"
+    if flag_column in df.columns:
+        flag_df = _prepare_boolean_indicator(df, flag_column)
+        try:
+            flag_pivot, _, _, _, _ = prepare_pivot(flag_df, flag_column)
+        except ValueError:
+            flag_pivot = None
+        if flag_pivot is not None:
+            flag_pivot = flag_pivot.reindex(
+                index=pd.Index(y_values, name=flag_pivot.index.name),
+                columns=pd.Index(x_values, name=flag_pivot.columns.name),
+            )
+            flag_values = flag_pivot.to_numpy(dtype=float)
+            mask_flag = np.isfinite(flag_values) & (flag_values > 0.5)
+            if np.any(mask_flag):
+                overlay = np.ma.masked_where(~mask_flag, mask_flag.astype(float))
+                highlight_cmap = ListedColormap(
+                    [
+                        (0.0, 0.0, 0.0, 0.0),
+                        (0.9, 0.2, 0.2, 0.35),
+                    ]
+                )
+                ax.imshow(
+                    overlay,
+                    origin="lower",
+                    cmap=highlight_cmap,
+                    aspect="auto",
+                )
+                legend_handles.append(
+                    patches.Patch(
+                        facecolor=(0.9, 0.2, 0.2, 0.35),
+                        edgecolor="none",
+                        label="s_min_eff > s_min_config",
+                    )
+                )
+
+    if legend_handles:
+        ax.legend(handles=legend_handles, loc="upper right", frameon=True)
+
+    ax.set_xticks(np.arange(-0.5, len(x_values), 1), minor=True)
+    ax.set_yticks(np.arange(-0.5, len(y_values), 1), minor=True)
+    ax.grid(which="minor", color="white", linewidth=0.5)
+    ax.tick_params(which="minor", bottom=False, left=False)
+
+    fig.tight_layout()
+    ensure_directory(Path("figures"))
+    output_path = Path("figures") / f"{map_stub}_s_min_effective.png"
+    fig.savefig(output_path, dpi=300)
+    plt.close(fig)
+    print(f"s_min_effective の図を {output_path} に保存しました。")
 
 
 def sanitize_metric_name(metric: str) -> str:
     """ファイル名に使いやすいメトリクス名へ変換する。"""
 
     return re.sub(r"[^A-Za-z0-9_.-]", "_", metric)
 
 
 def maybe_plot_mass_per_r2_scatter(df: pd.DataFrame, map_stub: str, map_label: str) -> None:
     """Map-1 系列向けの M/r^2 散布図を保存する。"""
 
     if "mass_per_r2" not in df.columns:
         return
     working = df.copy()
     run_status = working.get("run_status")
     if run_status is not None:
         working = working[run_status.astype(str).str.lower() == "success"]
     if "case_status" in working.columns:
         working = working[working["case_status"].astype(str).str.lower() == BLOWOUT_STATUS]
     working = working[pd.to_numeric(working["mass_per_r2"], errors="coerce").notna()]
     working = working[working["mass_per_r2"] > 0.0]
     if working.empty:
         return
 
     x_label = (
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..11006dc1b59b30232298dc8aada24a1bd0e813d8 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -267,47 +506,48 @@ def maybe_plot_mass_per_r2_scatter(df: pd.DataFrame, map_stub: str, map_label: s
         rel = float(np.max(np.abs(y - mean_val) / abs(mean_val))) if mean_val != 0.0 else math.nan
         if math.isfinite(rel):
             ax.text(0.02, 0.95, f"max|Δ|/mean = {rel:.3f}", transform=ax.transAxes, ha="left", va="top")
 
     handles, labels = ax.get_legend_handles_labels()
     if handles:
         ax.legend(loc="lower right")
     fig.tight_layout()
     output_path = Path("figures") / f"{map_stub}_mass_per_r2_scatter.png"
     ensure_directory(output_path.parent)
     fig.savefig(output_path, dpi=300)
     plt.close(fig)
     print(f"散布図を {output_path} に保存しました。")
 
 
 def main(argv: Iterable[str] | None = None) -> None:
     args = parse_args(None if argv is None else list(argv))
 
     try:
         map_stub, map_label = _normalise_map_key(args.map)
         df = load_csv(map_stub)
         pivot, x_values, y_values, x_label, y_label = prepare_pivot(df, args.metric)
         metric_name_for_file = sanitize_metric_name(args.metric)
         output_path = Path("figures") / f"{map_stub}_{metric_name_for_file}.png"
         plt.rcParams.update({"font.size": 12})
-        log_min, log_max = plot_heatmap(
+        log_min, log_max, _ = plot_heatmap(
             map_label,
             args.metric,
             pivot,
             x_values,
             y_values,
             x_label,
             y_label,
             output_path,
         )
         print(
             f"ヒートマップを {output_path} に保存しました (log10範囲: {log_min:.3f} – {log_max:.3f})。"
         )
+        maybe_plot_smin_effective_contours(df, map_stub, map_label, x_values, y_values, x_label, y_label)
         if map_stub in {"map1", "map1b"} and args.metric == DEFAULT_METRIC:
             maybe_plot_mass_per_r2_scatter(df, map_stub, map_label)
     except Exception as exc:  # pylint: disable=broad-except
         print(f"エラー: {exc}", file=sys.stderr)
         sys.exit(1)
 
 
 if __name__ == "__main__":
     main()
 
EOF
)

「Version 4」
Summary
case_status から失敗マスクを構築してピボットに含め、吹き飛ばし不成立ケースを一括で扱えるようにしました。 
ヒートマップ描画時に log10(M_loss / M_Mars) のカラーバー表記と失敗帯のハッチ付き凡例を追加し、連続した帯として表示されるよう改良しました。 
Testing
✅ python -m compileall scripts/plot_heatmaps.py 
⚠️ pytest tests/test_map1_validations.py （pandas が未インストールのため収集時に失敗）
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..254130723a8c057d62a9afc50f307310233e6c60 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -68,162 +68,217 @@ def load_csv(map_stub: str) -> pd.DataFrame:
         "map_id",
         "case_id",
         "param_x_name",
         "param_x_value",
         "param_y_name",
         "param_y_value",
     }
     missing = sorted(required_columns.difference(df.columns))
     if missing:
         raise ValueError(f"必要な列が不足しています: {', '.join(missing)}")
     return df
 
 
 def format_tick_label(value: object) -> str:
     """軸目盛のラベル文字列を生成する。"""
 
     if isinstance(value, float):
         if math.isfinite(value):
             return f"{value:g}"
         return str(value)
     return str(value)
 
 
 def prepare_pivot(
     df: pd.DataFrame, metric: str
-) -> Tuple[pd.DataFrame, List[object], List[object], str, str]:
+) -> Tuple[pd.DataFrame, pd.DataFrame | None, List[object], List[object], str, str]:
     """ピボットテーブルと軸ラベル情報を組み立てる。"""
 
     if metric not in df.columns:
         raise ValueError(f"指定されたメトリクス列が存在しません: {metric}")
 
     working = df.copy()
     working[metric] = pd.to_numeric(working[metric], errors="coerce")
+    failure_pivot: pd.DataFrame | None = None
     if "case_status" in working.columns:
         statuses = working["case_status"].astype(str).str.lower()
         working.loc[statuses != BLOWOUT_STATUS, metric] = np.nan
+        working["_failed_flag"] = statuses == "failed"
+    else:
+        working["_failed_flag"] = False
 
     x_label = (
         working["param_x_name"].dropna().iloc[0]
         if not working["param_x_name"].dropna().empty
         else "param_x"
     )
     y_label = (
         working["param_y_name"].dropna().iloc[0]
         if not working["param_y_name"].dropna().empty
         else "param_y"
     )
 
     x_order = working["param_x_value"].drop_duplicates().tolist()
     y_order = working["param_y_value"].drop_duplicates().tolist()
 
     working["param_x_value"] = pd.Categorical(working["param_x_value"], categories=x_order, ordered=True)
     working["param_y_value"] = pd.Categorical(working["param_y_value"], categories=y_order, ordered=True)
 
     pivot = working.pivot(index="param_y_value", columns="param_x_value", values=metric)
     pivot = pivot.reindex(
         index=pd.Index(y_order, name=pivot.index.name),
         columns=pd.Index(x_order, name=pivot.columns.name),
     )
 
-    return pivot, x_order, y_order, str(x_label), str(y_label)
+    if "_failed_flag" in working:
+        failure_pivot = working.pivot(
+            index="param_y_value",
+            columns="param_x_value",
+            values="_failed_flag",
+        )
+        failure_pivot = failure_pivot.reindex(
+            index=pd.Index(y_order, name=failure_pivot.index.name),
+            columns=pd.Index(x_order, name=failure_pivot.columns.name),
+        )
+        failure_pivot = failure_pivot.fillna(False).astype(bool)
+
+    return pivot, failure_pivot, x_order, y_order, str(x_label), str(y_label)
 
 
 def compute_log_values(pivot: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray, float, float]:
     """元の値と log10 値 (マスク付き) を計算する。"""
 
     values = pivot.to_numpy(dtype=float)
     finite = np.isfinite(values) & (values > 0.0)
     if not np.any(finite):
         raise ValueError("指定されたメトリクスに有効な値がありません。")
 
     log_values = np.full_like(values, np.nan, dtype=float)
     log_values[finite] = np.log10(values[finite])
     masked_log = np.ma.masked_invalid(log_values)
     log_min = float(np.min(log_values[finite]))
     log_max = float(np.max(log_values[finite]))
     return values, masked_log, log_min, log_max
 
 
 def plot_heatmap(
     map_label: str,
     metric: str,
     pivot: pd.DataFrame,
+    failure_pivot: pd.DataFrame | None,
     x_values: List[object],
     y_values: List[object],
     x_label: str,
     y_label: str,
     output_path: Path,
 ) -> Tuple[float, float]:
     """ヒートマップを描画して保存する。"""
 
     original_values, masked_log, log_min, log_max = compute_log_values(pivot)
 
     cmap = plt.get_cmap("viridis").copy()
     cmap.set_bad(color="lightgray")
 
     fig, ax = plt.subplots(figsize=(7.0, 6.0))
     im = ax.imshow(
         masked_log,
         origin="lower",
         cmap=cmap,
         aspect="auto",
         vmin=log_min,
         vmax=log_max,
     )
 
     x_ticks = np.arange(len(x_values))
     y_ticks = np.arange(len(y_values))
     ax.set_xticks(x_ticks)
     ax.set_xticklabels([format_tick_label(v) for v in x_values], rotation=45, ha="right")
     ax.set_yticks(y_ticks)
     ax.set_yticklabels([format_tick_label(v) for v in y_values])
     ax.set_xlabel(x_label)
     ax.set_ylabel(y_label)
     ax.set_title(f"{map_label}: {metric}")
 
     ax.set_xticks(np.arange(-0.5, len(x_values), 1), minor=True)
     ax.set_yticks(np.arange(-0.5, len(y_values), 1), minor=True)
     ax.grid(which="minor", color="white", linewidth=0.5)
     ax.tick_params(which="minor", bottom=False, left=False)
 
     cbar = fig.colorbar(im, ax=ax)
-    cbar.set_label(f"log10({metric})")
+    if metric == DEFAULT_METRIC:
+        cbar_label = "log10(M_loss / M_Mars)"
+    else:
+        cbar_label = f"log10({metric})"
+    cbar.set_label(cbar_label)
+
+    failure_mask = (
+        failure_pivot.to_numpy(dtype=bool)
+        if failure_pivot is not None
+        else np.zeros_like(original_values, dtype=bool)
+    )
 
     invalid_mask = ~np.isfinite(original_values) | (original_values <= 0.0)
+    invalid_mask |= failure_mask
     if np.any(invalid_mask):
-        for (y_idx, x_idx) in zip(*np.where(invalid_mask)):
-            rect = patches.Rectangle(
-                (x_idx - 0.5, y_idx - 0.5),
-                1.0,
-                1.0,
-                facecolor="none",
-                hatch="///",
-                edgecolor="gray",
-                linewidth=0.8,
-            )
-            ax.add_patch(rect)
+        hatch_patch = patches.Patch(
+            facecolor="lightgray",
+            edgecolor="gray",
+            hatch="///",
+            label="失敗/未計算",
+        )
+        legend_handles = [hatch_patch]
+        for y_idx, row in enumerate(invalid_mask):
+            start_idx: int | None = None
+            for x_idx, flagged in enumerate(row):
+                if flagged and start_idx is None:
+                    start_idx = x_idx
+                elif not flagged and start_idx is not None:
+                    width = x_idx - start_idx
+                    rect = patches.Rectangle(
+                        (start_idx - 0.5, y_idx - 0.5),
+                        width,
+                        1.0,
+                        facecolor="none",
+                        hatch="///",
+                        edgecolor="gray",
+                        linewidth=0.8,
+                    )
+                    ax.add_patch(rect)
+                    start_idx = None
+            if start_idx is not None:
+                width = len(row) - start_idx
+                rect = patches.Rectangle(
+                    (start_idx - 0.5, y_idx - 0.5),
+                    width,
+                    1.0,
+                    facecolor="none",
+                    hatch="///",
+                    edgecolor="gray",
+                    linewidth=0.8,
+                )
+                ax.add_patch(rect)
+        ax.legend(handles=legend_handles, loc="upper right", frameon=True)
 
     clim = im.get_clim()
     if not np.allclose(clim, (log_min, log_max), rtol=1e-6, atol=1e-8):
         raise RuntimeError("カラーバー範囲がCSVの最小値/最大値と一致しません。")
 
     fig.tight_layout()
     ensure_directory(output_path.parent)
     fig.savefig(output_path, dpi=300)
     plt.close(fig)
 
     return log_min, log_max
 
 
 def sanitize_metric_name(metric: str) -> str:
     """ファイル名に使いやすいメトリクス名へ変換する。"""
 
     return re.sub(r"[^A-Za-z0-9_.-]", "_", metric)
 
 
 def maybe_plot_mass_per_r2_scatter(df: pd.DataFrame, map_stub: str, map_label: str) -> None:
     """Map-1 系列向けの M/r^2 散布図を保存する。"""
 
     if "mass_per_r2" not in df.columns:
         return
     working = df.copy()
diff --git a/scripts/plot_heatmaps.py b/scripts/plot_heatmaps.py
index 34abc4823d03431dbcf5e5fcadd9eea96333b3df..254130723a8c057d62a9afc50f307310233e6c60 100644
--- a/scripts/plot_heatmaps.py
+++ b/scripts/plot_heatmaps.py
@@ -263,51 +318,52 @@ def maybe_plot_mass_per_r2_scatter(df: pd.DataFrame, map_stub: str, map_label: s
 
     mean_val = float(np.mean(y)) if len(y) else math.nan
     if math.isfinite(mean_val):
         ax.axhline(mean_val, color="gray", linestyle="--", linewidth=1.0, label="全体平均")
         rel = float(np.max(np.abs(y - mean_val) / abs(mean_val))) if mean_val != 0.0 else math.nan
         if math.isfinite(rel):
             ax.text(0.02, 0.95, f"max|Δ|/mean = {rel:.3f}", transform=ax.transAxes, ha="left", va="top")
 
     handles, labels = ax.get_legend_handles_labels()
     if handles:
         ax.legend(loc="lower right")
     fig.tight_layout()
     output_path = Path("figures") / f"{map_stub}_mass_per_r2_scatter.png"
     ensure_directory(output_path.parent)
     fig.savefig(output_path, dpi=300)
     plt.close(fig)
     print(f"散布図を {output_path} に保存しました。")
 
 
 def main(argv: Iterable[str] | None = None) -> None:
     args = parse_args(None if argv is None else list(argv))
 
     try:
         map_stub, map_label = _normalise_map_key(args.map)
         df = load_csv(map_stub)
-        pivot, x_values, y_values, x_label, y_label = prepare_pivot(df, args.metric)
+        pivot, failure_pivot, x_values, y_values, x_label, y_label = prepare_pivot(df, args.metric)
         metric_name_for_file = sanitize_metric_name(args.metric)
         output_path = Path("figures") / f"{map_stub}_{metric_name_for_file}.png"
         plt.rcParams.update({"font.size": 12})
         log_min, log_max = plot_heatmap(
             map_label,
             args.metric,
             pivot,
+            failure_pivot,
             x_values,
             y_values,
             x_label,
             y_label,
             output_path,
         )
         print(
             f"ヒートマップを {output_path} に保存しました (log10範囲: {log_min:.3f} – {log_max:.3f})。"
         )
         if map_stub in {"map1", "map1b"} and args.metric == DEFAULT_METRIC:
             maybe_plot_mass_per_r2_scatter(df, map_stub, map_label)
     except Exception as exc:  # pylint: disable=broad-except
         print(f"エラー: {exc}", file=sys.stderr)
         sys.exit(1)
 
 
 if __name__ == "__main__":
     main()
 
EOF
)