#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

REPO_ROOT = Path(__file__).resolve().parents[2]
ANALYSIS_DIR = REPO_ROOT / "analysis"
EQUATIONS_PATH = ANALYSIS_DIR / "equations.md"
INVENTORY_PATH = ANALYSIS_DIR / "inventory.json"
OUTPUT_PATH = ANALYSIS_DIR / "coverage" / "equations_todo.md"

ANCHOR_PATTERN = re.compile(r"(marsdisk/[A-Za-z0-9_/\.-]+\.py)#[A-Za-z0-9_\.]+")
SECTION_PATTERN = re.compile(r"^###\s+(.*)$", re.MULTILINE)


@dataclass
class InventoryEntry:
    file_path: str
    symbol: str
    line_no: int


def load_inventory() -> Dict[str, List[InventoryEntry]]:
    if not INVENTORY_PATH.exists():
        raise FileNotFoundError(f"Missing inventory file: {INVENTORY_PATH}")
    try:
        items = json.loads(INVENTORY_PATH.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:  # pragma: no cover - configuration error
        raise RuntimeError(f"Failed to parse inventory.json: {exc}") from exc

    grouped: Dict[str, List[InventoryEntry]] = {}
    for item in items:
        entry = InventoryEntry(
            file_path=item["file_path"],
            symbol=item["symbol"],
            line_no=item["line_no"],
        )
        grouped.setdefault(entry.file_path, []).append(entry)

    for entries in grouped.values():
        entries.sort(key=lambda e: e.line_no)
    return grouped


def iter_sections(text: str) -> Iterable[Tuple[str, str]]:
    matches = list(SECTION_PATTERN.finditer(text))
    for idx, match in enumerate(matches):
        start = match.end()
        end = matches[idx + 1].start() if idx + 1 < len(matches) else len(text)
        title = match.group(1).strip()
        section_body = text[start:end]
        yield title, section_body


def has_anchor(section_body: str) -> bool:
    return bool(ANCHOR_PATTERN.search(section_body))


def extract_file_from_title(title: str) -> Optional[str]:
    if ":" not in title:
        return None
    file_candidate = title.split(":", 1)[0].strip()
    if file_candidate.startswith("marsdisk/") and file_candidate.endswith(".py"):
        return file_candidate
    return None


def choose_candidates(entries: List[InventoryEntry], limit: int = 3) -> List[str]:
    suggestions: List[str] = []
    for entry in entries:
        if entry.symbol.startswith("_"):
            continue
        suggestions.append(f"{entry.file_path}#{entry.symbol}")
        if len(suggestions) >= limit:
            break
    if len(suggestions) < limit:
        for entry in entries:
            anchor = f"{entry.file_path}#{entry.symbol}"
            if anchor in suggestions:
                continue
            suggestions.append(anchor)
            if len(suggestions) >= limit:
                break
    return suggestions[:limit]


def build_report(missing_sections: List[Tuple[str, str]], inventory: Dict[str, List[InventoryEntry]]) -> str:
    lines: List[str] = [
        "# Equation Anchor TODO",
        "",
        "Generated by `python analysis/tools/list_equations_todo.py`.",
        "",
        "| Section | Suggested anchors |",
        "| --- | --- |",
    ]
    for title, file_path in missing_sections:
        entries = inventory.get(file_path, [])
        if entries:
            suggestions = ", ".join(choose_candidates(entries))
        else:
            suggestions = "_No symbols found in inventory_"
        lines.append(f"| `{title}` | {suggestions} |")
    lines.append("")
    return "\n".join(lines)


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(
        description="List equation sections lacking anchors and suggest symbols."
    )
    parser.parse_args(argv)

    inventory = load_inventory()
    text = EQUATIONS_PATH.read_text(encoding="utf-8")

    missing: List[Tuple[str, str]] = []
    for title, body in iter_sections(text):
        if has_anchor(body):
            continue
        file_path = extract_file_from_title(title)
        if not file_path:
            continue
        missing.append((title, file_path))

    OUTPUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    report = build_report(missing, inventory)
    OUTPUT_PATH.write_text(report, encoding="utf-8")

    if missing:
        print(f"Wrote {OUTPUT_PATH} with {len(missing)} section(s) missing anchors.")
    else:
        print("All equation sections already have anchors.")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
